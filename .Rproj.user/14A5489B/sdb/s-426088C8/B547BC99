{
    "collab_server" : "",
    "contents" : "#include <RcppArmadillo.h>\n#include <RcppArmadilloExtensions/sample.h>\nusing namespace Rcpp;\nusing namespace std;\n\n/*\n * We look at the model\n * Y_ij - \\phi_i (\\Theta_{ij} + \\delta_j)\n */\n\n\n// [[Rcpp::depends(\"RcppArmadillo\")]]\n// [[Rcpp::export]]\narma::mat multiplyXtXBySparse_c(int n, arma::uvec ind, arma::mat val, arma::vec phi, arma::vec w){\n  int p = val.n_cols;\n  int as = ind.size();\n  arma::uvec indrev = arma::zeros<arma::uvec>(n-1);\n  for (int i=0; i<(n-1); ++i){\n    indrev(i) = n-2-i;\n  }\n  arma::uvec o = sort_index(ind);\n  ind = sort(ind);\n  val = val.rows(o);\n  arma::vec phicum = cumsum(phi%phi);\n  arma::mat r = val.each_col() % w(ind);\n  arma::mat s1 = r.each_col() % phicum(ind);\n  arma::mat cumsums1 = cumsum(s1);\n  arma::rowvec s = cumsums1.row(as-1)/n;\n  arma::mat matrixT = arma::zeros<arma::mat>(n-1, p);\n  matrixT.rows(indrev(ind)) = r;\n  matrixT = cumsum(matrixT);\n  matrixT = matrixT.rows(indrev);\n  arma::mat u = matrixT.each_row()-s;\n  arma::vec phisq = phi%phi;\n  u.each_col() %= phisq.subvec(0,n-2);\n  arma::mat U = cumsum(u);\n  arma::mat C = U.each_col() % w;\n  return C;\n}\n\n// [[Rcpp::depends(\"RcppArmadillo\")]]\n// [[Rcpp::export]]\narma::mat leftMultiplyByXt_c(arma::mat Y, arma::vec phi, arma::vec w){\n  int n = Y.n_rows;\n  int p = Y.n_cols;\n  Y.each_col() %= phi;\n  arma::mat u = cumsum(Y);\n  arma::mat c = arma::zeros<arma::mat>(n-1,p);\n  arma::vec phicum = cumsum(phi%phi);\n  for (int i=0; i<p; ++i){\n    arma::vec x = u.col(i);\n    c.col(i) = w % (phicum.subvec(0,n-2) * (x(n-1)/n) - x.subvec(0,n-2));\n  }\n  return c;\n}\n\n// [[Rcpp::depends(\"RcppArmadillo\")]]\n// [[Rcpp::export]]\narma::mat leftMultiplyByInvXAtXA_c(double n, arma::uvec ind, arma::mat val, arma::vec phi, arma::vec w){\n  int a = val.n_rows;\n  int p = val.n_cols;\n  int as = ind.size();\n  arma::mat r = arma::zeros<arma::mat>(a, p);\n  if (a!=0){\n    arma::vec v1 = arma::zeros<arma::vec>(2+as);\n    v1(0) = 0;\n    arma::vec phicum = cumsum(phi%phi);\n    v1.subvec(1,as)=phicum(ind);\n    v1(as+1) = n;\n    arma::vec v = diff(v1);\n    arma::vec d = w(ind);\n    arma::mat R = arma::zeros<arma::mat>(a+2, p);\n    val.each_col() /= d;\n    R.row(0).fill(0);\n    R.rows(1,a) = val;\n    R.row(a+1).fill(0);\n    arma::mat gamma = diff(R);\n    arma::mat delta = gamma;\n    delta.each_col() /= v;\n    r = -diff(delta);\n    r.each_col() /= d;\n  }\n  return r;\n}\n\n// [[Rcpp::depends(\"RcppArmadillo\")]]\n// [[Rcpp::export]]\narma::vec ic_c(int k, arma::mat Y, arma::vec phi, arma::rowvec xi, arma::mat theta, int p, int n){\n  arma::mat dis = arma::zeros<arma::mat>(p, n);\n  int np = n*p;\n  double rss = 0;\n  for(int i = 0; i < p; ++i){\n    for(int j = 0; j < n; ++j){\n      dis(i, j) = Y(i, j) - (theta(i, j) + xi(j))*phi(i);\n      rss += dis(i, j)*dis(i, j);\n    }\n  }\n  rss = rss/(2*np);\n  const double bic_p = log(p) * ((k+1)*n + (p-k-1) + 2*k)/np;\n  const double temp1 = 2*((k+1)*n+(p-k-1)+3*k);\n  arma::vec out = arma::zeros<arma::vec>(3);\n  out[0] = rss;\n  out[1] = log(rss) + temp1/np;\n  out[2] = log(rss) + bic_p;\n  return out;\n}\n\n// [[Rcpp::depends(\"RcppArmadillo\")]]\n// [[Rcpp::export]]\narma::vec defaultWeights_c(int p){\n  arma::vec out = arma::zeros<arma::vec>(p-1);\n  for(int i = 0; i < (p-1); ++i){\n    double temp = (i+1) * (p-i-1);\n    out[i] = (sqrt(p/temp));\n  }\n  return out;\n}\n\n// [[Rcpp::depends(\"RcppArmadillo\")]]\n// [[Rcpp::export]]\nRcpp::List doLars_c(arma::mat Y, int K, arma::vec phi, arma::vec wts, int p, int n, double epsilon = 1e-09){\n  arma::vec res_lambda = arma::zeros<arma::vec>(K);\n  arma::uvec res_bkp = arma::zeros<arma::uvec>(K);\n  arma::mat res_value = arma::zeros<arma::mat>(K,n);\n  arma::mat res_value_old = arma::zeros<arma::mat>(K,n);\n  //arma::mat res_value;\n  //arma::mat res_value_old;\n  arma::mat result = arma::zeros<arma::mat>(K, n+2);\n  arma::uvec AS(1);\n  arma::uvec AS0(1);\n  /*empty the upper triangle*/\n  arma::mat c = leftMultiplyByXt_c(Y, phi, wts);\n  for (int ii=0; ii<K; ++ii){\n    arma::mat cc = c%c; //381 x 32\n    arma::mat ccrowsum = cumsum(cc, 1);\n    arma::vec cNorm = ccrowsum.col(n-1); //381x1\n    double bigcHat = cNorm.max();\n    if (ii==0){\n      AS(0) = cNorm.index_max();\n      res_bkp[ii] = cNorm.index_max();\n    }\n    //arma::uvec AS = res_bkp.subvec(0,ii);\n    arma::uvec I = sort_index(AS);\n    AS0 = AS;\n    AS = AS(I);\n    arma::mat w = leftMultiplyByInvXAtXA_c(p,AS,c.rows(AS),phi,wts);\n    arma::mat a = multiplyXtXBySparse_c(p, AS, w, phi, wts);\n    arma::mat aa = a%a;\n    arma::mat cumsumaa = cumsum(aa, 1);\n    arma::vec rowsumsa2 = cumsumaa.col(aa.n_cols-1);\n    arma::vec a1 = bigcHat - rowsumsa2;\n    arma::mat u = a%c;\n    arma::mat cumsumu = cumsum(u, 1);\n    arma::vec rowsumsu = cumsumu.col(u.n_cols-1);\n    arma::vec a2 = bigcHat-rowsumsu;\n    arma::vec a3 = bigcHat-cNorm;\n    arma::mat gammaTemp = arma::zeros<arma::mat>(p-1, 2);\n    gammaTemp.fill(NA_REAL);\n    arma::uvec subset = find(a1 > epsilon);\n    arma::vec delta = arma::zeros<arma::vec>(subset.size());\n    arma::uvec onetemp = arma::zeros<arma::uvec>(1);\n    arma::uvec twotemp = arma::ones<arma::uvec>(1);\n    delta = a2(subset)%a2(subset)-a1(subset)%a3(subset);\n    arma::uvec deltaneg = find(delta<0);\n    arma::uvec deltapos = find(delta>=0);\n    //if(deltaneg.size()>0){\n    arma::uvec delta_neg = subset(deltaneg);\n    gammaTemp.submat(delta_neg, onetemp).fill(NA_REAL);\n    gammaTemp.submat(delta_neg, twotemp).fill(NA_REAL);\n    //}\n    //if (deltapos.size()>0){\n    arma::uvec delta_pos = subset(deltapos);\n    gammaTemp.submat(delta_pos, onetemp) = (a2(delta_pos) +\n      sqrt(delta(deltapos)))/a1(delta_pos);\n    gammaTemp.submat(delta_pos, twotemp) = (a2(delta_pos) -\n      sqrt(delta(deltapos)))/a1(delta_pos);\n    //}\n    subset = find((a1 <= epsilon) && (a2 > epsilon));\n    //if(subset.size()>0){\n    arma::vec whattofill = a3(subset)/(2*a2(subset));\n    for (int i=0; i<subset.size(); ++i){\n      gammaTemp.row(subset[i]).fill(whattofill(i));\n    }\n    //}\n    double maxg = gammaTemp.max() + 1;\n    subset = find((a1 <= epsilon) && (a2 <= epsilon));\n    //if(subset.size()>0){\n    gammaTemp.rows(subset).fill(maxg);\n    //}\n    gammaTemp.rows(AS).fill(maxg);\n    gammaTemp(find(gammaTemp<=0)).fill(maxg);\n    double gamma = gammaTemp.min();\n    int idx = gammaTemp.index_min();\n    arma::uvec nexttoadd(1);\n    nexttoadd(0) = (idx)%(p-1);\n    double nexttoadd_double = nexttoadd(0);\n    res_lambda[ii] = sqrt(bigcHat);\n    res_value.fill(0);\n    res_value.rows(I) = gamma*w;\n    if(ii > 0){\n      res_value += res_value_old;\n    }\n    if (ii < (K-1)) {\n      AS = join_cols(AS0, nexttoadd);\n      res_bkp(ii+1) = nexttoadd_double;\n      c = c - gamma * a;\n    }\n    res_value_old = res_value;\n  }\n  arma::uvec one = arma::ones<arma::uvec>(res_bkp.size());\n  res_bkp += one;\n  return Rcpp::List::create(\n    Rcpp::Named(\"bkp\") = res_bkp,\n    Rcpp::Named(\"lambda\") = res_lambda,\n    Rcpp::Named(\"value\") = res_value\n  );\n}\n\n// [[Rcpp::depends(\"RcppArmadillo\")]]\n// [[Rcpp::export]]\nRcpp::List cnv_c(arma::mat Y, arma::vec wts, int steps, int maxloop=10){\n  /* Initialize phi*/\n  const int p = Y.n_rows;/*number of probes*/\n  const int n = Y.n_cols; /*number of samples*/\n  arma::vec phi = arma::ones<arma::vec>(p);\n  arma::rowvec xi = arma::ones<arma::rowvec>(n);\n  int loop = 0;\n  arma::vec phi_old = phi + 1e+10;\n  double error = 1e+10;\n  //double error2 = 1e+10;\n  while (error > 1e-5 & loop < 10){\n    arma::mat theta1 = (phi.t() * Y / p).t();\n    phi = Y * theta1 / accu(theta1 % theta1);\n    phi = phi / sqrt(accu(phi%phi)/p);\n    arma::vec diff = phi_old - phi;\n    error = sqrt(accu(diff%diff)/p);\n    phi_old = phi;\n    loop += 1;\n  }\n\n  /*Initialize variables to save*/\n  arma::vec aic_list = arma::zeros<arma::vec>(steps-1);\n  arma::vec bic_list = arma::zeros<arma::vec>(steps-1);\n  arma::vec rss_list = arma::zeros<arma::vec>(steps-1);\n  arma::vec loop_list = arma::zeros<arma::vec>(steps-1);\n  arma::mat bkp_list = arma::zeros<arma::mat>(steps-1, steps-1);\n  arma::mat phi_list = arma::zeros<arma::mat>(p, steps-1);\n  arma::mat xi_list = arma::zeros<arma::mat>(steps-1, n);\n  arma::cube theta_list = arma::zeros<arma::cube>(p, n, steps-1);\n\n  /* start computing the result for each k*/\n  for (int k = 1; k < (steps); ++k){\n    /* For each given k, we compute bkp, aic, etc*/\n    loop=0; error=1e5;\n    /* Initialize variable for next loop */\n    arma::mat theta = arma::zeros<arma::mat>(p, n);\n    arma::vec bkp = arma::zeros<arma::vec>(k);\n    arma::vec lambda = arma::zeros<arma::vec>(k);\n    arma::mat value = arma::zeros<arma::mat>(k, n);\n    arma::vec sorted_bkp = arma::zeros<arma::vec>(k);\n    arma::vec phi_new = arma::zeros<arma::vec>(p);\n    arma::rowvec xi_new = arma::zeros<arma::rowvec>(n);\n    arma::vec q = arma::zeros<arma::vec>(maxloop);\n    bool alternating = TRUE;\n    while (error > 1e-3 & loop<maxloop & alternating){\n      arma::mat Ynew = Y - phi*xi;\n      Rcpp::List lars = doLars_c(Ynew, k, phi, wts, p, n);\n      bkp = as<arma::vec>(lars[\"bkp\"]);\n      lambda = as<arma::vec>(lars[\"lambda\"]);\n      value = as<arma::mat>(lars[\"value\"]);\n      arma::uvec ord = sort_index(bkp);\n      sorted_bkp = sort(bkp);\n      arma::uvec sorted(k);\n      for (int i=0; i<k; ++i){\n        sorted(i) = sorted_bkp(i)-1;\n      }\n      arma::mat delta2 = arma::zeros<arma::mat>(p-1, n);\n      delta2.rows(sorted) = value.rows(ord);\n      arma::mat delta3 = arma::zeros<arma::mat>(p-1, n);\n      delta3 = delta2.each_col() % wts;\n      arma::mat delta1 = phi.t() * Ynew;\n      arma::vec phisq = phi%phi;\n      arma::vec cumsumphi = flipud(cumsum(flipud(phisq)));\n      cumsumphi.shed_row(0);\n      delta1 = (delta1-(cumsumphi.t() * delta3))/accu(phisq);\n      arma::mat delta = join_cols(delta1, delta3);\n      theta = delta;\n      for (int i=1; i<p; ++i){\n        theta.row(i) = theta.row(i-1) + delta.row(i);\n      }\n      arma::mat partition(k+1, p);\n      partition.fill(NA_REAL);\n      if (k==1){\n        for (int i=0; i < bkp(0); ++i){\n          partition(0, i) = i+1;\n        }\n        for (int i=bkp(0); i < p; ++i){\n          partition(1, i-bkp(0)) = i+1;\n        }\n      }\n      else{\n        for (int i=0; i < sorted(0)+1; ++i){\n          partition(0, i) = i+1;\n        }\n        for (int i=sorted(k-1)+1; i<p; ++i){\n          partition(k, i-sorted(k-1)-1) = i+1;\n        }\n        for (int i=0; i < (k-1); ++i){\n          for (int j=sorted(i)+1; j<sorted(i+1)+1; ++j){\n            partition(i+1, j-sorted(i)-1) = j+1;\n          }\n        }\n      }\n      arma::mat thetaY = theta%Y + Y.each_row()%xi;\n      arma::mat thetaYcumsum = cumsum(thetaY, 1);\n      arma::vec thetaYrowsum = thetaYcumsum.col(n-1);\n\n      arma::mat newtheta = theta.each_row() + xi;\n      arma::mat thetathetacumsum = cumsum(newtheta%newtheta, 1);\n      arma::vec thetasqrowsum = thetathetacumsum.col(n-1);\n      phi_new = thetaYrowsum / thetasqrowsum;\n      for (int i=0; i<(k+1); ++i){\n        arma::rowvec ith_partition = partition.row(i);\n        arma::vec where = ith_partition(find_finite(ith_partition));\n        arma::uvec uwhere = arma::zeros<arma::uvec>(where.size());\n        for (int j = 0; j < where.size(); ++j){\n          uwhere(j) = where(j)-1;\n        }\n        arma::vec phi_temp = phi_new(uwhere);\n        double phitempsqmean = mean(phi_temp%phi_temp);\n        phi_new(uwhere) = phi_temp/sqrt(phitempsqmean);\n      }\n      arma::vec diff = phi-phi_new;\n      error = accu(diff%diff) / p;\n      error = sqrt(error);\n      phi = phi_new;\n\n      arma::mat xitemp1 = (Y - theta.each_col()%phi);\n      arma::mat xitemp2 = xitemp1.each_col() % phi;\n      arma::mat xitempcumsum = cumsum(xitemp2, 0);\n      arma::rowvec colsumxi = xitempcumsum.row(p-1);\n      xi = colsumxi / accu(phi%phi);\n      //xi = xi*sqrt(n)/sqrt(accu(xi%xi));\n      arma::rowvec meanxi = arma::zeros<arma::rowvec>(n);\n      meanxi.fill(accu(xi)/n);\n      xi = xi - meanxi;\n\n      loop += 1;\n\n      //Compute the optimization objective Q1, check convergence\n\n      arma::vec res = ic_c(k,Y,phi,xi,theta,p,n);\n      double q1 = res(0) * 2* n * p;\n      for (int i = 0; i < (p-1); ++i){\n        arma::rowvec temp = theta.row(i+1)-theta.row(i);\n        q1 += lambda(k-1) * sqrt(accu(temp%temp)) / wts(i);\n      }\n      q(loop-1) = q1;\n      if(loop>5){\n        alternating = (abs(q(loop-1)-q(loop-3)) + abs(q(loop-2) - q(loop-4)) > 1e-3);\n      }\n    }\n    arma::vec res = ic_c(k, Y, phi, xi, theta, p, n);\n    rss_list(k-1) = res(0);\n    aic_list(k-1) = res(1);\n    bic_list(k-1) = res(2);\n    loop_list(k-1) = loop;\n    for (int i=0; i<k; ++i){\n      bkp_list(k-1, i) = sorted_bkp(i);\n    }\n    theta_list.slice(k-1) = theta;\n    phi_list.col(k-1) = phi;\n    xi_list.row(k-1) = xi;\n  }\n  int aic_k = aic_list.index_min();\n  int bic_k = bic_list.index_min();\n\n  /*Organize result*/\n  arma::rowvec tempaicbkp = bkp_list.row(aic_k);\n  arma::rowvec tempbicbkp = bkp_list.row(bic_k);\n  arma::vec aicbkp = arma::zeros<arma::vec>(aic_k+1);\n  arma::vec bicbkp = arma::zeros<arma::vec>(bic_k+1);\n  for (int i=0; i < aic_k+1; ++i){\n    aicbkp(i) = tempaicbkp(i)+1;\n  }\n  for (int i=0; i < bic_k+1; ++i){\n    bicbkp(i) = tempbicbkp(i)+1;\n  }\n  /*organize result*/\n  arma::mat aictheta = theta_list.slice(aic_k);\n  arma::vec aicphi = phi_list.col(aic_k);\n  arma::rowvec aicxi = xi_list.row(aic_k);\n  double aicrss = rss_list(aic_k);\n  double aicaic = aic_list(aic_k);\n  double aicbic = bic_list(bic_k);\n  arma::mat bictheta = theta_list.slice(bic_k);\n  arma::vec bicphi = phi_list.col(bic_k);\n  arma::rowvec bicxi = xi_list.row(bic_k);\n  double bicrss = rss_list(bic_k);\n  double bicaic = aic_list(bic_k);\n  double bicbic = bic_list(bic_k);\n  return Rcpp::List::create(\n    Rcpp::Named(\"aic\") = Rcpp::List::create(\n      Rcpp::Named(\"bkp\") = aicbkp,\n      Rcpp::Named(\"theta\") = aictheta,\n      Rcpp::Named(\"phi\") = aicphi,\n      Rcpp::Named(\"xi\") = aicxi,\n      Rcpp::Named(\"rss\") = aicrss,\n      Rcpp::Named(\"aic\") = aicaic,\n      Rcpp::Named(\"bic\") = aicbic\n    ),\n    Rcpp::Named(\"bic\") = Rcpp::List::create(\n      Rcpp::Named(\"bkp\") = bicbkp,\n      Rcpp::Named(\"theta\") = bictheta,\n      Rcpp::Named(\"phi\") = bicphi,\n      Rcpp::Named(\"xi\") = bicxi,\n      Rcpp::Named(\"rss\") = bicrss,\n      Rcpp::Named(\"aic\") = bicaic,\n      Rcpp::Named(\"bic\") = bicbic\n    ),\n    Rcpp::Named(\"bkp\") = bkp_list,\n    Rcpp::Named(\"aicerror\") = aic_list,\n    Rcpp::Named(\"bicerror\") = bic_list,\n    Rcpp::Named(\"rss\") = rss_list,\n    Rcpp::Named(\"looplist\") = loop_list\n  );\n}\n\n\n// [[Rcpp::depends(\"RcppArmadillo\")]]\n// [[Rcpp::export]]\ndouble get_f(arma::mat Y, arma::vec sigma, arma::vec delta){\n  double f = 0;\n  int p = Y.n_rows;\n  int n = Y.n_cols;\n  arma::mat Ysq = Y%Y;\n  arma::vec sigmasq = sigma%sigma;\n  arma::vec deltasq = delta%delta;\n  for (int i=0; i < p; ++i){\n    for (int j=0; j < n; ++j){\n      f -= log(sigmasq(i) + deltasq(j))/2;\n      f -= Ysq(i,j)/(2*(sigmasq(i) + deltasq(j)));\n    }\n  }\n  return f;\n}\n\n// [[Rcpp::depends(\"RcppArmadillo\")]]\n// [[Rcpp::export]]\narma::vec get_g(arma::mat Y, arma::vec sigma, arma::vec delta2){\n  int p = Y.n_rows;\n  int n = Y.n_cols;\n  arma::rowvec delta = arma::zeros<arma::rowvec>(n);\n  for (int i=0; i<n; ++i){\n    delta(i) = delta2(i);\n  }\n  arma::mat Ysq = Y%Y;\n  arma::mat gsig = arma::zeros<arma::mat>(p,n);\n  arma::mat gdel = arma::zeros<arma::mat>(p,n);\n  arma::mat sigmat = arma::zeros<arma::mat>(p,n);\n  arma::mat delmat = arma::zeros<arma::mat>(p,n);\n  sigmat.each_col()+=sigma;\n  delmat.each_row()+=delta;\n  gsig = -sigmat%sigmat%sigmat + sigmat%(Ysq-delmat%delmat);\n  arma::mat denom = sigmat%sigmat + delmat%delmat;\n  denom = denom%denom;\n  gsig = gsig / denom;\n  gdel = -delmat%delmat%delmat + delmat%(Ysq-sigmat%sigmat);\n  gdel = gdel / denom;\n  arma::mat cumgsig = cumsum(gsig, 1);\n  arma::mat cumgdel = cumsum(gdel.t(), 1);\n  arma::vec g = arma::zeros<arma::vec>(n+p);\n  g.subvec(0,p-1) = cumgsig.col(n-1);\n  g.subvec(p, n+p-1) = cumgdel.col(p-1);\n  return g;\n}\n\n// [[Rcpp::depends(\"RcppArmadillo\")]]\n// [[Rcpp::export]]\nRcpp::List get_f_and_g(arma::vec sigma, arma::vec delta, arma::mat Y){\n  double f = 0;\n  int p = Y.n_rows;\n  int n = Y.n_cols;\n  arma::mat Ysq = Y%Y;\n  arma::vec sigmasq = sigma%sigma;\n  arma::vec deltasq = delta%delta;\n  arma::mat gs = arma::zeros<arma::mat>(p,n);\n  arma::mat gd = arma::zeros<arma::mat>(n,p);\n  for (int i=0; i < p; ++i){\n    for (int j=0; j < n; ++j){\n      f -= log(sigmasq(i) + deltasq(j))/2;\n      f-= Ysq(i,j)/(2*(sigmasq(i) + deltasq(j)));\n      gs(i,j) = -pow(sigma(i), 3) + sigma(i)*(Ysq(i,j)-deltasq(j));\n      gs(i,j) /= pow(sigmasq(i) + deltasq(j), 2);\n      gd(j,i) = -pow(delta(j),3) + delta(j)*(Ysq(i,j)-sigmasq(i));\n      gd(j,i) /= pow(sigmasq(i) + deltasq(j), 2);\n    }\n  }\n  arma::vec g = arma::zeros<arma::vec>(p+n);\n  arma::mat cumsumgs = cumsum(gs,1);\n  g.subvec(0, p-1) = cumsumgs.col(n-1);\n  arma::mat cumsumgd = cumsum(gd, 1);\n  g.subvec(p, p+n-1) = cumsumgd.col(p-1);\n\n  return Rcpp::List::create(Rcpp::Named(\"f\") = f, Rcpp::Named(\"g\") = g);\n}\n\n// [[Rcpp::depends(\"RcppArmadillo\")]]\n// [[Rcpp::export]]\ndouble get_alpha(arma::mat Y, double alpha, double rho, double c, arma::vec sigma, arma::vec delta){\n  int p = Y.n_rows;\n  int n = Y.n_cols;\n  double f1 = get_f(Y, sigma, delta);\n  arma::vec g1 = get_g(Y, sigma, delta);\n  double g1cross = accu(g1%g1);\n  int maxit = 1000;\n  int it = 1;\n  double f2 = f1-100;\n  while(f2 > f1 - c*alpha*g1cross && it < maxit){\n    arma::vec sigma2 = sigma - alpha*g1.subvec(0,p-1);\n    arma::vec delta2 = delta - alpha*g1.subvec(p, p+n-1);\n    f2 = get_f(Y, sigma2, delta2);\n    alpha = alpha * rho;\n    it = it + 1;\n  }\n  return alpha;\n}\n\n// [[Rcpp::depends(\"RcppArmadillo\")]]\n// [[Rcpp::export]]\nRcpp::List grdesc(arma::mat Y, arma::vec sig, arma::vec del, int maxit){\n  int p = Y.n_rows;\n  int n = Y.n_cols;\n  arma::vec newsig = sig;\n  arma::vec newdel = del;\n  arma::vec g = arma::zeros<arma::vec>(n+p);\n  double alpha0 = 1;\n  double rho = 0.9;\n  double c = 0.1;\n  double diff = 1;\n  int it = 1;\n  double alpha = 10;\n  while(it < maxit && diff > 1e-4){\n    alpha = get_alpha(Y, alpha0, rho, c, sig, del);\n    g = get_g(Y, sig, del);\n    newsig = sig - alpha * g.subvec(0,p-1);\n    newdel = del - alpha * g.subvec(p, n+p-1);\n    diff = accu((newsig-sig)%(newsig-sig))+accu((newdel-del)%(newdel-del));\n    sig = newsig;\n    del = newdel;\n    it += 1;\n  }\n  return Rcpp::List::create(\n    Rcpp::Named(\"sigma\") = newsig, Rcpp::Named(\"delta\") = newdel\n  );\n}\n\n\n\n/////////////////OLD VERSIONS OF CODES//////////\n// [[Rcpp::depends(\"RcppArmadillo\")]]\n// [[Rcpp::export]]\narma::mat multiplyXtXBySparse_c_old(int n, arma::uvec ind, arma::mat val, arma::vec phi, arma::vec w){\n  int p = val.n_cols;\n  int as = ind.size();\n  arma::uvec indrev = arma::zeros<arma::uvec>(n-1);\n  for (int i=0; i<(n-1); ++i){\n    indrev(i) = n-2-i;\n  }\n  arma::uvec o = sort_index(ind);\n  ind = sort(ind);\n  val = val.rows(o);\n  arma::vec phicum = cumsum(phi%phi);\n  arma::mat r = val.each_col() % w(ind);\n  arma::mat s1 = r.each_col() % phicum(ind);\n  arma::mat cumsums1 = cumsum(s1);\n  arma::rowvec s = cumsums1.row(as-1)/n;\n  arma::mat matrixT = arma::zeros<arma::mat>(n-1, p);\n  matrixT.rows(indrev(ind)) = r;\n  matrixT = cumsum(matrixT);\n  matrixT = matrixT.rows(indrev);\n  arma::mat u = matrixT.each_row()-s;\n  arma::vec phisq = phi%phi;\n  u.each_col() %= phisq.subvec(0,n-2);\n  arma::mat U = cumsum(u);\n  arma::mat C = U.each_col() % w;\n  return C;\n}\n\n// [[Rcpp::depends(\"RcppArmadillo\")]]\n// [[Rcpp::export]]\narma::mat leftMultiplyByXt_c_old(arma::mat Y, arma::vec phi, arma::vec w){\n  int n = Y.n_rows;\n  int p = Y.n_cols;\n  Y.each_col() %= phi;\n  arma::mat u = cumsum(Y);\n  arma::mat c = arma::zeros<arma::mat>(n-1,p);\n  arma::vec phicum = cumsum(phi%phi);\n  for (int i=0; i<p; ++i){\n    arma::vec x = u.col(i);\n    c.col(i) = w % (phicum.subvec(0,n-2) * (x(n-1)/n) - x.subvec(0,n-2));\n  }\n  return c;\n}\n\n// [[Rcpp::depends(\"RcppArmadillo\")]]\n// [[Rcpp::export]]\narma::mat leftMultiplyByInvXAtXA_c_old(double n, arma::uvec ind, arma::mat val, arma::vec phi, arma::vec w){\n  int a = val.n_rows;\n  int p = val.n_cols;\n  int as = ind.size();\n  arma::mat r = arma::zeros<arma::mat>(a, p);\n  if (a!=0){\n    arma::vec v1 = arma::zeros<arma::vec>(2+as);\n    v1(0) = 0;\n    arma::vec phicum = cumsum(phi%phi);\n    v1.subvec(1,as)=phicum(ind);\n    v1(as+1) = n;\n    arma::vec v = diff(v1);\n    arma::vec d = w(ind);\n    arma::mat R = arma::zeros<arma::mat>(a+2, p);\n    val.each_col() /= d;\n    R.row(0).fill(0);\n    R.rows(1,a) = val;\n    R.row(a+1).fill(0);\n    arma::mat gamma = diff(R);\n    arma::mat delta = gamma;\n    delta.each_col() /= v;\n    r = -diff(delta);\n    r.each_col() /= d;\n  }\n  return r;\n}\n\n// [[Rcpp::depends(\"RcppArmadillo\")]]\n// [[Rcpp::export]]\narma::vec ic_c_old(int k, arma::mat Y, arma::vec phi, arma::mat theta, double p, double n){\n  arma::mat dis = arma::zeros<arma::mat>(p, n);\n  double np = n*p;\n  double rss = 0;\n  for(int i = 0; i < p; ++i){\n    for(int j = 0; j < n; ++j){\n      dis(i, j) = Y(i, j) - theta(i, j)*phi(i);\n      rss += dis(i, j)*dis(i, j);\n    }\n  }\n  rss = rss/(2*np);\n  const double bic_p = log(p) * ((k+1)*n + (p-k-1) + 2*k)/np;\n  const double temp1 = 2*((k+1)*n+(p-k-1)+3*k);\n  arma::vec out = arma::zeros<arma::vec>(3);\n  out[0] = rss;\n  out[1] = log(rss) + temp1/np;\n  out[2] = log(rss) + bic_p;\n  return out;\n}\n\n// [[Rcpp::depends(\"RcppArmadillo\")]]\n// [[Rcpp::export]]\narma::vec defaultWeights_c_old(int p){\n  arma::vec out = arma::zeros<arma::vec>(p-1);\n  for(int i = 0; i < (p-1); ++i){\n    double temp = (i+1) * (p-i-1);\n    out[i] = (sqrt(p/temp));\n  }\n  return out;\n}\n\n// [[Rcpp::depends(\"RcppArmadillo\")]]\n// [[Rcpp::export]]\nRcpp::List doLars_slow_old(arma::mat Y, int K, arma::vec phi, arma::vec wts, int p, int n, double epsilon = 1e-09){\n  arma::vec res_lambda = arma::zeros<arma::vec>(K);\n  arma::uvec res_bkp = arma::zeros<arma::uvec>(K);\n  arma::mat res_value = arma::zeros<arma::mat>(K,n);\n  arma::mat res_value_old = arma::zeros<arma::mat>(K,n);\n  arma::mat matrixT = phi * wts.t(); //382 x 381\n  arma::mat result = arma::zeros<arma::mat>(K, n+2);\n  /*empty the upper triangle*/\n  for (int i = 0; i < matrixT.n_cols; ++i){\n    matrixT.submat(i,i,i, matrixT.n_cols-1).fill(0);\n  }\n  arma::mat QT1 = phi.t() * matrixT; //1x381\n  arma::mat QT2 = (phi/p) * QT1; //382 x 381\n  arma::mat QT = matrixT - QT2; //382 x 381\n  arma::mat QY1 = phi.t() * Y; //1x32\n  arma::mat QY2 = (phi/p) * QY1; //382x32\n  arma::mat QY = Y - QY2; //382x32\n  arma::mat c = QT.t() * QY; //381 x 32\n  for (int ii=0; ii<K; ++ii){\n    arma::mat cc = c%c; //381 x 32\n    arma::mat ccrowsum = cumsum(cc, 1);\n    arma::vec cNorm = ccrowsum.col(n-1); //381x1\n    double bigcHat = cNorm.max();\n    if (ii==0){\n      res_bkp[ii] = cNorm.index_max();\n    }\n    arma::uvec AS = res_bkp.subvec(0,ii);\n    arma::uvec I = sort_index(AS);\n    arma::mat w1 = inv_sympd(QT.cols(AS).t() * QT.cols(AS)); //(ii+1)x(ii+1)\n    arma::mat w = w1 * c.rows(AS); //(ii+1) x n\n    arma::mat tempa = QT.t() * QT.cols(AS); //(p-1)x(ii+1)\n    arma::mat a = tempa * w; //(p-1)xn\n    arma::mat aa = a%a;\n    arma::mat cumsumaa = cumsum(aa, 1);\n    arma::vec rowsumsa2 = cumsumaa.col(aa.n_cols-1);\n    arma::vec a1 = bigcHat - rowsumsa2;\n    arma::mat u = a%c;\n    arma::mat cumsumu = cumsum(u, 1);\n    arma::vec rowsumsu = cumsumu.col(u.n_cols-1);\n    arma::vec a2 = bigcHat-rowsumsu;\n    arma::vec a3 = bigcHat-cNorm;\n    arma::mat gammaTemp = arma::zeros<arma::mat>(p-1, 2);\n    gammaTemp.fill(NA_REAL);\n    arma::uvec subset = find(a1 > epsilon);\n    arma::vec delta = arma::zeros<arma::vec>(subset.size());\n    arma::uvec onetemp = arma::zeros<arma::uvec>(1);\n    arma::uvec twotemp = arma::ones<arma::uvec>(1);\n    delta = a2(subset)%a2(subset)-a1(subset)%a3(subset);\n    arma::uvec deltaneg = find(delta<0);\n    arma::uvec deltapos = find(delta>=0);\n    if(deltaneg.size()>0){\n      arma::uvec delta_neg = subset(deltaneg);\n      gammaTemp.submat(delta_neg, onetemp).fill(NA_REAL);\n      gammaTemp.submat(delta_neg, twotemp).fill(NA_REAL);\n    }\n    if (deltapos.size()>0){\n      arma::uvec delta_pos = subset(deltapos);\n      gammaTemp.submat(delta_pos, onetemp) = (a2(delta_pos) +\n        sqrt(delta(deltapos)))/a1(delta_pos);\n      gammaTemp.submat(delta_pos, twotemp) = (a2(delta_pos) -\n        sqrt(delta(deltapos)))/a1(delta_pos);\n    }\n    subset = find((a1 <= epsilon) && (a2 > epsilon));\n    if(subset.size()>0){\n      arma::vec whattofill = a3(subset)/(2*a2(subset));\n      for (int i=0; i<subset.size(); ++i){\n        gammaTemp.row(subset[i]).fill(whattofill(i));\n      }\n    }\n    double maxg = gammaTemp.max() + 1;\n    subset = find((a1 <= epsilon) && (a2 <= epsilon));\n    if(subset.size()>0){\n      gammaTemp.rows(subset).fill(maxg);\n    }\n    gammaTemp.rows(AS).fill(maxg);\n    gammaTemp(find(gammaTemp<=0)).fill(maxg);\n    double gamma = gammaTemp.min();\n    int idx = gammaTemp.index_min();\n    int nexttoadd = (idx)%(p-1);\n    res_lambda[ii] = sqrt(bigcHat);\n    res_value.rows(0,ii) = gamma*w;\n    if(ii > 0){\n      res_value += res_value_old;\n    }\n    if (ii < (K-1)) {\n      res_bkp(ii+1) = nexttoadd;\n      c = c - gamma * a;\n    }\n    res_value_old = res_value;\n  }\n  arma::uvec one = arma::ones<arma::uvec>(res_bkp.size());\n  res_bkp += one;\n  return Rcpp::List::create(\n    Rcpp::Named(\"bkp\") = res_bkp,\n    Rcpp::Named(\"lambda\") = res_lambda,\n    Rcpp::Named(\"value\") = res_value\n  );\n}\n\n// [[Rcpp::depends(\"RcppArmadillo\")]]\n// [[Rcpp::export]]\nRcpp::List doLars_c_old(arma::mat Y, int K, arma::vec phi, arma::vec wts, int p, int n, double epsilon = 1e-09){\n  arma::vec res_lambda = arma::zeros<arma::vec>(K);\n  arma::uvec res_bkp = arma::zeros<arma::uvec>(K);\n  arma::mat res_value = arma::zeros<arma::mat>(K,n);\n  arma::mat res_value_old = arma::zeros<arma::mat>(K,n);\n  //arma::mat res_value;\n  //arma::mat res_value_old;\n  arma::mat result = arma::zeros<arma::mat>(K, n+2);\n  arma::uvec AS(1);\n  arma::uvec AS0(1);\n  /*empty the upper triangle*/\n  arma::mat c = leftMultiplyByXt_c_old(Y, phi, wts);\n  for (int ii=0; ii<K; ++ii){\n    arma::mat cc = c%c; //381 x 32\n    arma::mat ccrowsum = cumsum(cc, 1);\n    arma::vec cNorm = ccrowsum.col(n-1); //381x1\n    double bigcHat = cNorm.max();\n    if (ii==0){\n      AS(0) = cNorm.index_max();\n      res_bkp[ii] = cNorm.index_max();\n    }\n    //arma::uvec AS = res_bkp.subvec(0,ii);\n    arma::uvec I = sort_index(AS);\n    AS0 = AS;\n    AS = AS(I);\n    arma::mat w = leftMultiplyByInvXAtXA_c_old(p,AS,c.rows(AS),phi,wts);\n    arma::mat a = multiplyXtXBySparse_c_old(p, AS, w, phi, wts);\n    arma::mat aa = a%a;\n    arma::mat cumsumaa = cumsum(aa, 1);\n    arma::vec rowsumsa2 = cumsumaa.col(aa.n_cols-1);\n    arma::vec a1 = bigcHat - rowsumsa2;\n    arma::mat u = a%c;\n    arma::mat cumsumu = cumsum(u, 1);\n    arma::vec rowsumsu = cumsumu.col(u.n_cols-1);\n    arma::vec a2 = bigcHat-rowsumsu;\n    arma::vec a3 = bigcHat-cNorm;\n    arma::mat gammaTemp = arma::zeros<arma::mat>(p-1, 2);\n    gammaTemp.fill(NA_REAL);\n    arma::uvec subset = find(a1 > epsilon);\n    arma::vec delta = arma::zeros<arma::vec>(subset.size());\n    arma::uvec onetemp = arma::zeros<arma::uvec>(1);\n    arma::uvec twotemp = arma::ones<arma::uvec>(1);\n    delta = a2(subset)%a2(subset)-a1(subset)%a3(subset);\n    arma::uvec deltaneg = find(delta<0);\n    arma::uvec deltapos = find(delta>=0);\n    //if(deltaneg.size()>0){\n    arma::uvec delta_neg = subset(deltaneg);\n    gammaTemp.submat(delta_neg, onetemp).fill(NA_REAL);\n    gammaTemp.submat(delta_neg, twotemp).fill(NA_REAL);\n    //}\n    //if (deltapos.size()>0){\n    arma::uvec delta_pos = subset(deltapos);\n    gammaTemp.submat(delta_pos, onetemp) = (a2(delta_pos) +\n      sqrt(delta(deltapos)))/a1(delta_pos);\n    gammaTemp.submat(delta_pos, twotemp) = (a2(delta_pos) -\n      sqrt(delta(deltapos)))/a1(delta_pos);\n    //}\n    subset = find((a1 <= epsilon) && (a2 > epsilon));\n    //if(subset.size()>0){\n    arma::vec whattofill = a3(subset)/(2*a2(subset));\n    for (int i=0; i<subset.size(); ++i){\n      gammaTemp.row(subset[i]).fill(whattofill(i));\n    }\n    //}\n    double maxg = gammaTemp.max() + 1;\n    subset = find((a1 <= epsilon) && (a2 <= epsilon));\n    //if(subset.size()>0){\n    gammaTemp.rows(subset).fill(maxg);\n    //}\n    gammaTemp.rows(AS).fill(maxg);\n    gammaTemp(find(gammaTemp<=0)).fill(maxg);\n    double gamma = gammaTemp.min();\n    int idx = gammaTemp.index_min();\n    arma::uvec nexttoadd(1);\n    nexttoadd(0) = (idx)%(p-1);\n    double nexttoadd_double = nexttoadd(0);\n    res_lambda[ii] = sqrt(bigcHat);\n    res_value.fill(0);\n    res_value.rows(I) = gamma*w;\n    if(ii > 0){\n      res_value += res_value_old;\n    }\n    if (ii < (K-1)) {\n      AS = join_cols(AS0, nexttoadd);\n      res_bkp(ii+1) = nexttoadd_double;\n      c = c - gamma * a;\n    }\n    res_value_old = res_value;\n  }\n  arma::uvec one = arma::ones<arma::uvec>(res_bkp.size());\n  res_bkp += one;\n  return Rcpp::List::create(\n    Rcpp::Named(\"bkp\") = res_bkp,\n    Rcpp::Named(\"lambda\") = res_lambda,\n    Rcpp::Named(\"value\") = res_value\n  );\n}\n\n// [[Rcpp::depends(\"RcppArmadillo\")]]\n// [[Rcpp::export]]\nRcpp::List cnv_c_old(arma::mat Y, arma::vec wts, int steps, int maxloop=10){\n  /* Initialize phi*/\n  const int p = Y.n_rows;/*number of probes*/\n  const int n = Y.n_cols; /*number of samples*/\n  arma::vec phi = arma::ones<arma::vec>(p);\n  int loop = 0;\n  arma::vec phi_old = phi + 1e+10;\n  double error = 1e+10;\n  //double error2 = 1e+10;\n  while (error > 1e-5 & loop < 10){\n    arma::mat theta1 = (phi.t() * Y / p).t();\n    phi = Y * theta1 / accu(theta1 % theta1);\n    phi = phi / sqrt(accu(phi%phi)/p);\n    arma::vec diff = phi_old - phi;\n    error = sqrt(accu(diff%diff)/p);\n    phi_old = phi;\n    loop += 1;\n  }\n  /*Initialize variables to save*/\n  arma::vec aic_list = arma::zeros<arma::vec>(steps-1);\n  arma::vec bic_list = arma::zeros<arma::vec>(steps-1);\n  arma::vec rss_list = arma::zeros<arma::vec>(steps-1);\n  arma::vec loop_list = arma::zeros<arma::vec>(steps-1);\n  arma::mat bkp_list = arma::zeros<arma::mat>(steps-1, steps-1);\n  arma::mat phi_list = arma::zeros<arma::mat>(p, steps-1);\n  arma::cube theta_list = arma::zeros<arma::cube>(p, n, steps-1);\n\n  /* start computing the result for each k*/\n  for (int k = 1; k < (steps); ++k){\n    /* For each given k, we compute bkp, aic, etc*/\n    loop=0; error=1e5;\n    /* Initialize variable for next loop */\n    arma::mat theta = arma::zeros<arma::mat>(p, n);\n    arma::vec bkp = arma::zeros<arma::vec>(k);\n    arma::vec lambda = arma::zeros<arma::vec>(k);\n    arma::mat value = arma::zeros<arma::mat>(k, n);\n    arma::vec sorted_bkp = arma::zeros<arma::vec>(k);\n    arma::vec phi_new = arma::zeros<arma::vec>(p);\n    arma::vec q = arma::zeros<arma::vec>(maxloop);\n    bool alternating = TRUE;\n    while (error > 1e-5 & loop<maxloop & alternating){\n      Rcpp::List lars = doLars_c_old(Y, k, phi, wts, p, n);\n      bkp = as<arma::vec>(lars[\"bkp\"]);\n      lambda = as<arma::vec>(lars[\"lambda\"]);\n      value = as<arma::mat>(lars[\"value\"]);\n      arma::uvec ord = sort_index(bkp);\n      sorted_bkp = sort(bkp);\n      arma::uvec sorted(k);\n      for (int i=0; i<k; ++i){\n        sorted(i) = sorted_bkp(i)-1;\n      }\n      arma::mat delta2 = arma::zeros<arma::mat>(p-1, n);\n      delta2.rows(sorted) = value.rows(ord);\n      arma::mat delta3 = arma::zeros<arma::mat>(p-1, n);\n      delta3 = delta2.each_col() % wts;\n      arma::mat delta1 = phi.t() * Y;\n      arma::vec phisq = phi%phi;\n      arma::vec cumsumphi = flipud(cumsum(flipud(phisq)));\n      cumsumphi.shed_row(0);\n      delta1 = (delta1-(cumsumphi.t() * delta3))/accu(phisq);\n      arma::mat delta = join_cols(delta1, delta3);\n      theta = delta;\n      for (int i=1; i<p; ++i){\n        theta.row(i) = theta.row(i-1) + delta.row(i);\n      }\n      arma::mat partition(k+1, p);\n      partition.fill(NA_REAL);\n      if (k==1){\n        for (int i=0; i < bkp(0); ++i){\n          partition(0, i) = i+1;\n        }\n        for (int i=bkp(0); i < p; ++i){\n          partition(1, i-bkp(0)) = i+1;\n        }\n      }\n      else{\n        for (int i=0; i < sorted(0)+1; ++i){\n          partition(0, i) = i+1;\n        }\n        for (int i=sorted(k-1)+1; i<p; ++i){\n          partition(k, i-sorted(k-1)-1) = i+1;\n        }\n        for (int i=0; i < (k-1); ++i){\n          for (int j=sorted(i)+1; j<sorted(i+1)+1; ++j){\n            partition(i+1, j-sorted(i)-1) = j+1;\n          }\n        }\n      }\n      arma::mat thetaY = theta%Y;\n      arma::mat thetaYcumsum = cumsum(thetaY, 1);\n      arma::mat thetathetacumsum = cumsum(theta%theta, 1);\n      arma::vec thetaYrowsum = thetaYcumsum.col(n-1);\n      arma::vec thetasqrowsum = thetathetacumsum.col(n-1);\n      phi_new = thetaYrowsum / thetasqrowsum;\n      for (int i=0; i<(k+1); ++i){\n        arma::rowvec ith_partition = partition.row(i);\n        arma::vec where = ith_partition(find_finite(ith_partition));\n        arma::uvec uwhere = arma::zeros<arma::uvec>(where.size());\n        for (int j = 0; j < where.size(); ++j){\n          uwhere(j) = where(j)-1;\n        }\n        arma::vec phi_temp = phi_new(uwhere);\n        double phitempsqmean = mean(phi_temp%phi_temp);\n        phi_new(uwhere) = phi_temp/sqrt(phitempsqmean);\n      }\n      arma::vec diff = phi-phi_new;\n      error = accu(diff%diff) / p;\n      error = sqrt(error);\n      phi = phi_new;\n      arma::vec res = ic_c_old(k,Y,phi,theta,p,n);\n      loop += 1;\n      //Compute the optimization objective Q1, check convergence\n      double q1 = res(0) * 2* n * p;\n      for (int i = 0; i < (p-1); ++i){\n        arma::rowvec temp = theta.row(i+1)-theta.row(i);\n        q1 += lambda(k-1) * sqrt(accu(temp%temp)) / wts(i);\n      }\n      q(loop-1) = q1;\n      if(loop>5){\n        alternating = (abs(q(loop-1)-q(loop-3)) + abs(q(loop-2) - q(loop-4)) > 1e-2);\n      }\n    }\n    arma::vec res = ic_c_old(k, Y, phi, theta, p, n);\n    rss_list(k-1) = res(0);\n    aic_list(k-1) = res(1);\n    bic_list(k-1) = res(2);\n    loop_list(k-1) = loop;\n    for (int i=0; i<k; ++i){\n      bkp_list(k-1, i) = sorted_bkp(i);\n    }\n    theta_list.slice(k-1) = theta;\n    phi_list.col(k-1) = phi;\n  }\n  int aic_k = aic_list.index_min();\n  int bic_k = bic_list.index_min();\n\n  /*Organize result*/\n  arma::rowvec tempaicbkp = bkp_list.row(aic_k);\n  arma::rowvec tempbicbkp = bkp_list.row(bic_k);\n  arma::vec aicbkp = arma::zeros<arma::vec>(aic_k+1);\n  arma::vec bicbkp = arma::zeros<arma::vec>(bic_k+1);\n  for (int i=0; i < aic_k+1; ++i){\n    aicbkp(i) = tempaicbkp(i)+1;\n  }\n  for (int i=0; i < bic_k+1; ++i){\n    bicbkp(i) = tempbicbkp(i)+1;\n  }\n  /*organize result*/\n  arma::mat aictheta = theta_list.slice(aic_k);\n  arma::vec aicphi = phi_list.col(aic_k);\n  double aicrss = rss_list(aic_k);\n  double aicaic = aic_list(aic_k);\n  double aicbic = bic_list(bic_k);\n  arma::mat bictheta = theta_list.slice(bic_k);\n  arma::vec bicphi = phi_list.col(bic_k);\n  double bicrss = rss_list(bic_k);\n  double bicaic = aic_list(bic_k);\n  double bicbic = bic_list(bic_k);\n  return Rcpp::List::create(\n    Rcpp::Named(\"aic\") = Rcpp::List::create(\n      Rcpp::Named(\"bkp\") = aicbkp,\n      Rcpp::Named(\"theta\") = aictheta,\n      Rcpp::Named(\"phi\") = aicphi,\n      Rcpp::Named(\"rss\") = aicrss,\n      Rcpp::Named(\"aic\") = aicaic,\n      Rcpp::Named(\"bic\") = aicbic\n    ),\n    Rcpp::Named(\"bic\") = Rcpp::List::create(\n      Rcpp::Named(\"bkp\") = bicbkp,\n      Rcpp::Named(\"theta\") = bictheta,\n      Rcpp::Named(\"phi\") = bicphi,\n      Rcpp::Named(\"rss\") = bicrss,\n      Rcpp::Named(\"aic\") = bicaic,\n      Rcpp::Named(\"bic\") = bicbic\n    ),\n    Rcpp::Named(\"bkp\") = bkp_list,\n    Rcpp::Named(\"aicerror\") = aic_list,\n    Rcpp::Named(\"bicerror\") = bic_list,\n    Rcpp::Named(\"rss\") = rss_list,\n    Rcpp::Named(\"looplist\") = loop_list\n  );\n}\n\n\n\n\n\n",
    "created" : 1507433887551.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4071913450",
    "id" : "B547BC99",
    "lastKnownWriteTime" : 1507215486,
    "last_content_update" : 1507215486,
    "path" : "~/Dropbox/TaeProject/CopyNumber/CopyNumberCellShift/src/all_functions.cpp",
    "project_path" : "src/all_functions.cpp",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}